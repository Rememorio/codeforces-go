// Code generated by copypasta/template/generator_test.go
package main

import (
	"github.com/EndlessCheng/codeforces-go/main/testutil"
	"github.com/stretchr/testify/assert"
	"testing"
)

// https://codeforces.com/contest/1927/problem/F
// https://codeforces.com/problemset/status/1927/problem/F
func Test_cf1927F(t *testing.T) {
	testCases := [][2]string{
		{
			`5
6 6
1 2 1
2 3 1
3 1 1
4 5 1
5 6 1
6 4 1
6 6
1 2 10
2 3 8
3 1 5
4 5 100
5 6 40
6 4 3
6 15
1 2 4
5 2 8
6 1 7
6 3 10
6 5 1
3 2 8
4 3 4
5 3 6
2 6 6
5 4 5
4 1 3
6 4 5
4 2 1
3 1 7
1 5 5
4 6
2 3 2
1 3 10
1 4 1
3 4 7
2 4 5
1 2 2
4 5
2 1 10
3 1 3
4 2 6
1 4 7
2 3 3`,
			`1 3
1 2 3 
3 3
6 4 5 
1 5
4 2 1 6 3 
1 4
1 4 3 2 
3 3
2 3 1`,
		},
		{
			`1
5 6
1 2 1
2 3 1
2 4 1
2 5 1
3 4 3
3 5 2`,
			`-1`,
		},
		{
			`1
7 8
1 2 1
2 3 1
1 4 2
4 5 1
5 6 3
2 7 3
3 7 1
4 6 1`,
			`-1`,
		},
	}
	testutil.AssertEqualStringCase(t, testCases, 0, cf1927F)
}

func TestCheck_cf1927F(_t *testing.T) {
	//return
	assert := assert.New(_t)
	_ = assert

	testutil.DebugTLE = 0

	inputGenerator := func() (string, testutil.OutputChecker) {
		rg := testutil.NewRandGenerator()
		rg.One() // 若不是多测则 remove
		n := rg.Int(3, 10)
		m := rg.Int(n, n*(n-1)/2)
		rg.NewLine()
		rg.GraphWeightedEdges(n, m, 1, 1, 3, false)
		return rg.String(), func(myOutput string) (_b bool) {
			//// 检查 myOutput 是否符合题目要求
			//// * 最好重新看一遍题目描述以免漏判 *
			//// 对于 special judge 的题目，可能还需要额外跑个暴力来检查 myOutput 是否满足最优解等
			//in := strings.NewReader(myOutput)
			//
			//myA := make([]int, n)
			//for i := range myA {
			//	Fscan(in, &myA[i])
			//}
			//if !assert.EqualValues(a, myA) {
			//	return
			//}

			return true
		}
	}

	testutil.CheckRunResultsInfWithTarget(_t, inputGenerator, 0, cf1927F)
}

//func TestCompare_cf1927F(_t *testing.T) {
//	//return
//	testutil.DebugTLE = 0
//
//	inputGenerator := func() string {
//		//return ``
//		rg := testutil.NewRandGenerator()
//		rg.One() // 若不是多测则 remove
//		n := rg.Int(4, 5)
//		m := rg.Int(n, n+2)
//		rg.NewLine()
//		rg.GraphWeightedEdges(n, m, 1, 1, 3, false)
//		return rg.String()
//	}
//
//	// 暴力算法
//	runBF := func(in io.Reader, out io.Writer) {
//		solve := func(Case int) {
//			
//			type edge struct {
//				next, to, w int
//			}
//
//			const (
//				N = ll(50)
//			)
//
//			var n, k int
//			var e [N * 2]edge
//			var h [N]int
//			var nxt int
//
//			add := func(u, v, w int) {
//				nxt++
//				e[nxt] = edge{h[u], v, w}
//				h[u] = nxt
//			}
//			Init := func() {
//				nxt = 1
//				for i := 0; i <= n; i++ {
//					h[i] = -1
//				}
//			}
//
//			var dep, siz [N]int
//			var anss []int
//		
//			var dfs func(u, f, end int) ll
//			dfs = func(u, f, end int) ll {
//				if u == end {
//					return 1
//				}
//				for i := h[u]; i != -1; i = e[i].next {
//					v := e[i].to
//					if v != f {
//						anss = append(anss, v)
//						if dfs(v, u, end) == 1 {
//							return 1
//						}
//						anss = anss[0 : len(anss)-1]
//					}
//				}
//				return 0
//			}
//		
//			
//			Fscan(in, &n, &k)
//			a := make([]node, k)
//			Init()
//			for i := 0; i < k; i++ {
//				Fscan(in, &a[i].u, &a[i].v, &a[i].w)
//			}
//			sort.Sort(SortBy(a))
//			ans := int(1e9)
//			p := 0
//			fa = make([]int, n+1)
//			for i := 0; i < n+1; i++ {
//				fa[i] = i
//			}
//			for i := 0; i < k; i++ {
//				x, y := find(a[i].u), find(a[i].v)
//				if x != y {
//					add(a[i].u, a[i].v, 1)
//					add(a[i].v, a[i].u, 1)
//					fa[x] = y
//				} else {
//					ans = min(ans, a[i].w)
//					p = i
//				}
//			}
//			anss = make([]int, 0)
//			anss = append(anss, a[p].u)
//			dfs(a[p].u, a[p].u, a[p].v)
//			Fprintln(out, ans, len(anss))
//			for _, v := range anss {
//				Fprintln(out, v, " ")
//			}
//			Fprintln(out)
//		}
//
//		T := 1
//		Fscan(in, &T) //
//		for Case := 1; Case <= T; Case++ {
//			solve(Case)
//		}
//
//		_leftData, _ := io.ReadAll(in)
//		if _s := strings.TrimSpace(string(_leftData)); _s != "" {
//			panic("有未读入的数据：\n" + _s)
//		}
//	}
//
//	testutil.AssertEqualRunResultsInf(_t, inputGenerator, runBF, cf1927F)
//}
//var fa []int
//
//func find(x int) int {
//	if x == fa[x] {
//		return x
//	}
//	fa[x] = find(fa[x])
//	return fa[x]
//}
//type node struct {
//	u, v int
//	w    int
//}
//type SortBy []node
//
//func (a SortBy) Len() int           { return len(a) }
//func (a SortBy) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
//func (a SortBy) Less(i, j int) bool { return a[i].w > a[j].w }
