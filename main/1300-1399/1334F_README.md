考虑需要删除哪些数。
看示例 1 来启发思考。最后一个数是 10，它的下标是 i，那么 i 右边比 10 大的数都需要删除。
枚举倒数第二个数 7 的位置 j，那么从 j 到 i 之间的比 7 大的数都需要删除。
对于 7 又需要枚举 3 的位置，以此类推。

这说明：
1. 需要用到 DP。
2. 需要用一个合适的数据结构，维护需要删除的数的 cost 之和，即在一个区间内的 a 值大于某个数的 cost 值之和。

定义 f[i] 表示 record 子序列的最后一个数是 a[i] 的最小代价和。如果 a[i] 不在 b 中则 f[i]=inf。
我的做法是按照 b 数组的顺序从小到大 DP：先把 a 中所有等于 b[0] 的 f 值算出来，然后把 a 中所有等于 b[1] 的 f 值算出来，……
在计算等于 b[j] 的 f 值时，可以用双指针遍历 a 中所有 b[j-1] 和 b[j] 的位置。
比如 b[j-1]=1, b[j]=3，a 数组是 1 9 1 9 3 9 1 9 1 9 3，那么第一个 3 的转移来源有两个 1：
· 第一个 1 的 f 值 + 从第一个 1 到第一个 3 之间大于 1 的数的 cost 和。
· 第二个 1 的 f 值 + 从第二个 1 到第一个 3 之间大于 1 的数的 cost 和。
这两个的最小值记作 mn。
那么第二个 3 呢？它也可以从前两个 1（以及其它的 1）转移过来，照这样算岂不是至少平方的复杂度了？
我们可以在 mn 的基础上，增加从第一个 3（包含）到第二个 3（不包含）之间的大于 1 的数的 cost 和，这样就直接得到了前两个 1 到第二个 3 的最小转移了。

计算 cost 和，可以用树状数组维护，随着 b[j] 的变大，要及时移除树状数组中的小于等于 b[j-1] 的 cost 和，这样计算出的大于 b[j-1] 的数的 cost 和才是正确的。

最后，在删除的过程中，如果数字的 cost 是负数，也可以删除。
可以单独用一个前缀和记录负数 cost。
